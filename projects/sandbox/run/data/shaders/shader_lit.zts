Anything outside of < < [ ] > > will be ignored

<<[glsl_vs]>>
<<[
	#version 330 core
	layout (location = 0) in vec3 position;
	layout (location = 1) in vec2 tex_coord; 
	layout (location = 2) in vec3 normal;
	layout (location = 3) in vec4 color;

	out VS_OUT {
		vec3 frag_pos;
		vec3 normal;
		vec2 tex_coord;
		vec4 color;
		vec4 frag_pos_light_space;
	} vs_out;

	uniform mat4 model;
	uniform mat4 projection;
	uniform mat4 view;
	uniform mat4 light_matrix;

	void main()
	{
		gl_Position = projection * view * model * vec4(position, 1.0);
		vs_out.frag_pos = vec3(model * vec4(position, 1.0));
		vs_out.normal = normalize(transpose(inverse(mat3(model))) * normal);
		vs_out.tex_coord = tex_coord;
		vs_out.color = color;
		vs_out.frag_pos_light_space = light_matrix * vec4(vs_out.frag_pos, 1.0);
	}
]>>

<<[glsl_fs]>>
<<[
	#version 330 core
	out vec4 frag_color;

	in VS_OUT {
		vec3 frag_pos;
		vec3 normal;
		vec2 tex_coord;
		vec4 color;
		vec4 frag_pos_light_space;
	} fs_in;

	uniform sampler2D diffuse_tex;
	uniform sampler2D specular_tex;
	uniform sampler2D normal_tex;
	uniform sampler2D shadowmap_directional_tex;
	uniform vec4 diffuse_color;
	uniform vec4 specular_color;
	uniform float shininess;
	
	uniform vec3 light_pos;
	uniform vec3 view_pos;
	
	float shadowCalculation(vec3 light_dir)
	{
		vec3 proj_coords = fs_in.frag_pos_light_space.xyz / fs_in.frag_pos_light_space.w;
		proj_coords = proj_coords * 0.5 + 0.5;
		
		//float closest_depth = texture(shadowmap_directional_tex, proj_coords.xy).r;
		float current_depth = proj_coords.z;
		
		float bias = 0;//max(0.05 * (1.0 - dot(fs_in.normal, light_dir)), 0.005);
		
		float shadow = 0.0;
		vec2 texel_size = 1.0 / textureSize(shadowmap_directional_tex, 0);
		
		const int samples = 3;
		for(int x = -samples; x <= samples; ++x) {
			for(int y = -samples; y <= samples; ++y) {
				float pcf_depth = texture(shadowmap_directional_tex, proj_coords.xy + vec2(x, y) * texel_size).r;
				shadow += current_depth - bias > pcf_depth ? 1.0 : 0.0f;
			}
		}
		shadow /= (samples * 2 + 1) * (samples * 2 + 1);
		return shadow;
	}
	
	float specularCalculation(vec3 light_dir)
	{
		vec3 view_dir = normalize(view_pos - fs_in.frag_pos);
		vec3 halfway_dir = normalize(light_dir + view_dir);
		float spec_value = texture(specular_tex, fs_in.tex_coord).r;
		return pow(max(dot(fs_in.normal, halfway_dir), 0.0), 256.0) * shininess * 5 * spec_value;
	}
	
	void main()
	{
		vec4 clr = texture(diffuse_tex, fs_in.tex_coord) * fs_in.color;
		vec4 light_color = vec4(1,1,1,1);
        
		vec4 ambient = 0.25 * clr;
		vec3 light_dir = normalize(light_pos - fs_in.frag_pos);
		float diff = max(dot(light_dir, fs_in.normal), 0.0);
		vec4 diffuse = diff * light_color * diffuse_color;
     
		vec4 specular = specularCalculation(light_dir) * light_color * specular_color;

		float shadow = shadowCalculation(light_dir);
		vec4 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * clr;
        
		frag_color = vec4(lighting.xyz, 1);
	};
]>>

<<[hlsl_vs, vertexShader]>>
<<[
	cbuffer MatrixBuffer : register(b0)
	{
		matrix model;
		matrix view;
		matrix projection;
		matrix light_matrix;
		float3 light_pos;
		float3 view_pos;
	};

	struct VertexInputType
	{
		float3 position : POSITION;
		float2 tex_coord : TEXCOORD0;
		float3 normal : NORMAL;
		float4 color : COLOR;
	};

	struct FragmentInputType
	{
		float4 position : SV_POSITION;
		float3 normal : NORMAL;
		float2 tex_coord : TEXCOORD0;
		float4 color : COLOR0;
		float4 frag_pos : POSITION0;
		float4 frag_pos_light_space : POSITION1;
		float4 light_pos : POSITION2;
		float4 view_pos : POSITION3;
	};


	FragmentInputType vertexShader(VertexInputType input)
	{
		FragmentInputType output;
		float4 position4 = float4(input.position, 1);
		output.position = mul(position4, model);
		output.position = mul(output.position, view);
		output.position = mul(output.position, projection);
		
		
		output.tex_coord = input.tex_coord;
		output.color = input.color;
		output.frag_pos = float4(mul(position4, model).xyz, 1);
		output.frag_pos_light_space = mul(output.frag_pos, light_matrix);

		//output.normal = mul(transpose(model), float4(input.normal, 0)).xyz;
		//output.normal = mul(float4(input.normal, 0), transpose(model)).xyz;
		output.normal = normalize(mul(input.normal, transpose((float3x3)model)));

		output.light_pos = float4(light_pos, 1);
		output.view_pos = float4(view_pos, 1);
		
		return output;
	}
]>>

<<[hlsl_fs, fragmentShader]>>
<<[
	Texture2D diffuse_tex;
	Texture2D specular_tex;
	Texture2D normal_tex;
	Texture2D shadowmap_directional_tex;
	SamplerState sample_type;

	cbuffer VariableBuffer : register(b0)
	{
		float4 diffuse_color;
		float4 specular_color;
		float  shininess;
	};

	struct FragmentInputType
	{
		float4 position : SV_POSITION;
		float3 normal : NORMAL;
		float2 tex_coord : TEXCOORD0;
		float4 color : COLOR0;
		float4 frag_pos : POSITION0;
		float4 frag_pos_light_space : POSITION1;
		float4 light_pos : POSITION2;
		float4 view_pos : POSITION3;
	};


	float shadowCalculation(FragmentInputType input, float3 light_dir)
	{
		float3 proj_coords = input.frag_pos_light_space.xyz / input.frag_pos_light_space.w;
		proj_coords = proj_coords * 0.5 + 0.5;
		proj_coords.y = 1 - proj_coords.y;
		
		
		float current_depth = input.frag_pos_light_space.z;
		//float current_depth = proj_coords.z;
		
		float3 normal = normalize(input.normal);
		float bias = max(0.05 * (1.0 - dot(normal, light_dir)), 0.005);
		
		float shadow = 0.0;
		uint tex_w = 0, tex_h = 0;
		shadowmap_directional_tex.GetDimensions(tex_w, tex_h);
		float2 texel_size = 1.0 / float2(tex_w, tex_h);
		
		const int samples = 3;
		for(int x = -samples; x <= samples; ++x) {
			for(int y = -samples; y <= samples; ++y) {
				float pcf_depth = shadowmap_directional_tex.Sample(sample_type, proj_coords.xy + float2(x, y) * texel_size).r;
				//shadow += (1 - (pcf_depth - bias));//current_depth - bias > pcf_depth ? 1.0 : 0.0f;
				shadow += current_depth - bias > pcf_depth ? 1: 0.0f;
			}
		}
		shadow /= (samples * 2 + 1) * (samples * 2 + 1);
		return shadow;
	}
	
	float specularCalculation(FragmentInputType input, float3 light_dir)
	{
		// not sure why this doesn't work... the math is identical to the OpenGL version which works
		float3 view_dir = normalize(input.view_pos - input.frag_pos).xyz;
		float3 halfway_dir = normalize(light_dir + view_dir);
		float spec_value = specular_tex.Sample(sample_type, input.tex_coord).r;
		float spec = pow(max(dot(input.normal, halfway_dir), 0.0), 256.0) * shininess * 5 * spec_value;
		// return spec;
		return 0;
	}

	float4 fragmentShader(FragmentInputType input) : SV_TARGET
	{
		float4 color = diffuse_tex.Sample(sample_type, input.tex_coord) * input.color;
		float3 light_color = float3(1,1,1);
		
		float3 light_dir = normalize(input.light_pos - input.frag_pos).xyz;
		float diff = max(dot(light_dir, input.normal), 0);
		float3 diffuse = diff * light_color * diffuse_color.rgb;
		
		float3 specular = 0;//specularCalculation(input, light_dir) * light_color * specular_color.rgb;
		float shadow = shadowCalculation(input, light_dir);
		
		float3 ambient = color.xyz * 0.25;
		float3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color.xyz;
		
		return float4(lighting, 1.0f);
	}
]>>
