// shader-lit

struct VertexInput
{
	vec3 position : 0;
	vec2 uv : 1;
	vec3 normal : 2;
	vec4 color : 3;
	vec4 tangent : 4;
	vec4 bitangent : 5;
}

struct PixelInput
{
	vec4 position : position;
	vec3 frag_pos;
	vec3 normal;
	vec2 uv;
	vec4 color;
	vec4 frag_pos_light_space;
	mat3 tbn;
}

struct PixelOutput
{
	vec4 color : color;
}

struct Textures
{
	texture2d diffuse_tex;
	texture2d specular_tex;
	texture2d normal_tex;
	texture2d shadowmap_directional_tex;
}

struct PointLight
{
	vec3 pos;
	
	float intensity;

	vec3 ambient_color;
	vec3 diffuse_color;
	vec3 specular_color;
}

struct Uniforms
{
	mat4 model;
	mat4 view;
	mat4 projection;
	mat4 light_matrix;

	vec4 diffuse_color;
	vec4 specular_color;
	float shininess;
	
	vec3 view_pos;

	vec3 light_pos;
	float light_ambient;
	float light_intensity;
	vec4 light_color;
	
	PointLight point_lights[4];
	int point_lights_count;
}

vec3 normalCalculation(PixelInput input, Textures textures)
{
	vec3 normal = textureSample(textures.normal_tex, input.uv).rgb;
	if (normal.x == 1 && normal.y == 1 && normal.z == 1) {
		return input.normal;
	}
	normal = normalize(input.normal * 2.0 - 1.0);
	normal = normalize(input.tbn * input.normal);
	return normal;
}

float shadowCalculation(vec3 light_dir, vec3 normal, PixelInput input, Textures textures)
{
	return 0;
}

float specularCalculation(vec3 light_dir, vec3 normal, vec3 view_dir, PixelInput input, Uniforms uniforms, Textures textures)
{
	vec3 halfway_dir = normalize(light_dir + view_dir);
	float spec_value = textureSample(textures.specular_tex, input.uv).r;
	return pow(max(dot(normal, halfway_dir), 0.0), 256.0) * uniforms.shininess * 5.0 * spec_value;
}

vec4 directionalLightCalculation(vec4 clr, vec3 normal, vec3 view_dir, PixelInput input, Uniforms uniforms, Textures textures)
{
	vec4 light_clr = uniforms.light_color * uniforms.light_intensity;
	
	vec3 light_dir = normalize(uniforms.light_pos - input.frag_pos);
	float diff = max(dot(light_dir, normal), 0.0);
	vec4 diffuse = diff * light_clr;
 
	vec4 specular = specularCalculation(light_dir, normal, view_dir, input, uniforms, textures) * light_clr * uniforms.specular_color;
	float shadow = shadowCalculation(light_dir, normal, input, textures);

	vec4 ambient_clr = clr * uniforms.light_ambient;
	return (ambient_clr + (1.0 - shadow) * (diffuse + specular)) * clr;
}

vec4 pointLightCalculation(vec4 clr, vec3 normal, vec3 view_dir, PointLight light, PixelInput input, Uniforms uniforms, Textures textures)
{
	vec4 light_clr = vec4(light.ambient_color, 1);
	
	vec3 light_dir = normalize(light.pos - input.frag_pos);
	float diff = max(dot(light_dir, normal), 0.0);
	vec4 diffuse = diff * light_clr;
 
	vec4 specular = specularCalculation(light_dir, normal, view_dir, input, uniforms, textures) * light_clr;// * specular_color;
	float shadow = 0;//shadowCalculation(light_dir, normal, input, textures);

	float distance = length(light.pos - input.frag_pos);
	float constant = 1;
	float linear = 0.7 - (.693 * light.intensity);
	float quadratic = 1.8 - (1.7998 * light.intensity);
	float attenuation = 1.0 * light.intensity;
	
	return ((1.0 - shadow) * (diffuse + specular)) * clr * attenuation;
}

program DefaultLit
{
	vertex_shader vertexShader(VertexInput input : input, Uniforms uniforms : uniforms, PixelInput output : output)
	{
		output.position = uniforms.projection * uniforms.view * uniforms.model * vec4(input.position, 1.0);
		output.frag_pos = vec3(uniforms.model * vec4(input.position, 1.0));
		output.normal = normalize(transpose(inverse(mat3(uniforms.model))) * input.normal);
		output.uv = input.uv;
		output.color = input.color;
		output.frag_pos_light_space = uniforms.light_matrix * vec4(output.frag_pos, 1.0);
		
		vec3 t = normalize(vec3(uniforms.model * input.tangent));
		vec3 b = normalize(vec3(uniforms.model * input.bitangent));
		vec3 n = normalize(vec3(uniforms.model * vec4(input.normal, 0)));
		output.tbn = mat3(t, b, n);
	}

	pixel_shader pixelShader(PixelInput input : input, Uniforms uniforms : uniforms, Textures textures : textures, PixelOutput output : output)
	{
		vec4 clr = textureSample(textures.diffuse_tex, input.uv) * input.color * uniforms.diffuse_color;
		vec3 normal = normalCalculation(input, textures);
		vec3 view_dir = normalize(uniforms.view_pos - input.frag_pos);
		vec4 lighting = directionalLightCalculation(clr, normal, view_dir, input, uniforms, textures);
		
		for(int i = 0; i < uniforms.point_lights_count; ++i) {
			lighting += pointLightCalculation(clr, normal, view_dir, uniforms.point_lights[i], input, uniforms, textures);
		}
        
		output.color = vec4(lighting.xyz, 1);
	}
}