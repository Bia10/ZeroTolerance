Anything outside of < < [ ] > > will be ignored

<<[glsl_vs]>>
<<[
	#version 330 core
	layout (location = 0) in vec3 position;
	layout (location = 1) in vec2 tex_coord; 
	layout (location = 2) in vec3 normal;

	out VS_OUT {
		vec3 frag_pos;
		vec3 normal;
		vec2 tex_coord;
	} vs_out;

	uniform mat4 model;
	uniform mat4 projection;
	uniform mat4 view;

	void main()
	{
		gl_Position = projection * view * model * vec4(position, 1.0);
		//gl_Position = vec4(position, 1);
		//vs_out.frag_pos = vec3(model * vec4(position, 1.0));
		vs_out.tex_coord = tex_coord;
	}
]>>

<<[glsl_fs]>>
<<[
	#version 330 core
	out vec4 frag_color;

	in VS_OUT {
		vec3 frag_pos;
		vec3 normal;
		vec2 tex_coord;
	} fs_in;

	uniform sampler2D tex_diffuse;
	uniform vec4 color = vec4(1,1,1,1);

	void main()
	{
		vec4 clr = texture(tex_diffuse, fs_in.tex_coord);
		//clr *= vec4(1,0,0,1);
		frag_color = clr;
	};
]>>

<<[hlsl_vs, vertexShader]>>
<<[
	cbuffer MatrixBuffer : register(b0)
	{
		matrix model;
		matrix view;
		matrix projection;
	};

	struct VertexInputType
	{
		float3 position : POSITION;
		float2 tex_coord : TEXCOORD0;
		float3 normal : NORMAL;
	};

	struct FragmentInputType
	{
		float4 position : SV_POSITION;
		float2 tex_coord : TEXCOORD0;
		float4 mat_tests : COLOR;
	};


	FragmentInputType vertexShader(VertexInputType input)
	{
		FragmentInputType output;
		float4 position4 = float4(input.position, 1);
		output.position = mul(position4, model);
		output.position = mul(output.position, view);
		output.position = mul(output.position, projection);
		output.position.w = 1.0;
		
		output.mat_tests = float4(1,1,1,1);
//		output.position = float4(input.position.x, input.position.y, input.position.z, 1);
//		
//		output.mat_tests = mul(output.position, projection);
//		output.mat_tests = float4(projection._m00, projection._m01, projection._m02, 1);
//		output.mat_tests = float4(abs(projection._m00) + abs(projection._m01) + abs(projection._m02) + abs(projection._m03) + 
//								  abs(projection._m10) + abs(projection._m11) + abs(projection._m12) + abs(projection._m13) + 
//								  abs(projection._m20) + abs(projection._m21) + abs(projection._m22) + abs(projection._m23) + 
//								  abs(projection._m30) + abs(projection._m31) + abs(projection._m32) + abs(projection._m33), 0, 0, 1);
//		//output.position = mul(output.position, projection);
				
		output.tex_coord = input.tex_coord;
		
		return output;
	}
]>>

<<[hlsl_fs, fragmentShader]>>
<<[
	Texture2D tex_diffuse;
	SamplerState sample_type;

	struct FragmentInputType
	{
		float4 position : SV_POSITION;
		float2 tex_coord : TEXCOORD0;
		float4 mat_tests : COLOR;
	};


	float4 fragmentShader(FragmentInputType input) : SV_TARGET
	{
		float4 color = tex_diffuse.Sample(sample_type, input.tex_coord);
		//color = float4(0,1,0,1);
		//color = input.mat_tests;
		color.a = 1;
		return color;
	}
]>>
