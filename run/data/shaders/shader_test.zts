/* 
	zt shader file
*/

glsl_vs[0] =
"
	#version 330 core
	layout (location = 0) in vec3 position;
	layout (location = 1) in vec4 color;
	layout (location = 2) in vec2 tex_coord;
	layout (location = 3) in vec3 normal;

	out VS_OUT {
		vec3 frag_pos;
		vec3 normal;
		vec2 tex_coord;
		vec4 color;
		vec4 frag_pos_light_space;
	} vs_out;

	uniform mat4 model;
	uniform mat4 projection;
	uniform mat4 view;
	uniform mat4 light_matrix;

	void main()
	{
		gl_Position = projection * view * model * vec4(position, 1.0);
		vs_out.frag_pos = vec3(model * vec4(position, 1.0));
		vs_out.normal = transpose(inverse(mat3(model))) * normal;
		vs_out.tex_coord = tex_coord;
		vs_out.color = color;
		vs_out.frag_pos_light_space = light_matrix * vec4(vs_out.frag_pos, 1.0);
	}
"

glsl_fs[0] =
"
	#version 330 core
	out vec4 frag_color;

	in VS_OUT {
		vec3 frag_pos;
		vec3 normal;
		vec2 tex_coord;
		vec4 color;
		vec4 frag_pos_light_space;
	} fs_in;

	uniform sampler2D tex_diffuse;
	uniform sampler2D tex_shadow_map;
	uniform vec3 light_pos;
	uniform vec3 view_pos;
	uniform vec4 color = vec4(1,1,1,1);

	void main()
	{
		vec3 clr = texture(tex_diffuse, fs_in.tex_coord).rgb * fs_in.color.rgb;
		vec3 normal = normalize(fs_in.normal);
		vec3 light_color = vec3(1);

		vec3 ambient = 0.75 * clr;
		vec3 light_dir = normalize(light_pos - fs_in.frag_pos);
		float diff = max(dot(light_dir, normal), 0.0);
		vec3 diffuse = diff * light_color;

		vec3 view_dir = normalize(view_pos - fs_in.frag_pos);
		float spec = 0.0;
		vec3 halfway_dir = normalize(light_dir + view_dir);
		spec = pow(max(dot(normal, halfway_dir), 0.0), 64.0);
		vec3 specular = vec3(0,0,0);//spec * light_color;

		vec3 proj_coords = fs_in.frag_pos_light_space.xyz / fs_in.frag_pos_light_space.w;
		proj_coords = proj_coords * 0.5 + 0.5;
		float shadow = 0;
		if(proj_coords.z <= 1.0) {
	//		float bias = max(0.05 * (1.0 - dot(normal, light_dir)), 0.005);
			float bias = 0.00;//025;
			float current_depth = proj_coords.z;
			vec2 texel_size = 1.0 / textureSize(tex_shadow_map, 0);
			const int samples = 3;
			for(int x = -samples; x <= samples; ++x) {
				for(int y = -samples; y <= samples; ++y) {
					float closest_depth = texture(tex_shadow_map, proj_coords.xy + vec2(x,y) * texel_size).r;
					shadow += current_depth - bias > closest_depth ? 1.0 : 0.0f;
				}
			}
			shadow /= (samples * 2 + 1) * (samples * 2 + 1);
	//		shadow = current_depth - bias > closest_depth ? 1.0 : 0.0;
		}
		vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * clr;

		frag_color = vec4(lighting, 1.0f) * color;

	//	vec3 norm = normalize(fs_in.normal);
	//	vec3 light_dir = normalize(light_pos- fs_in.frag_pos);
	//	float diff = max(dot(norm, light_dir), 0.0);
	//	vec3 diffuse = diff * vec3(1,1,1);
	//	vec3 result = diffuse * fs_in.color.rgb;
	//	frag_color = texture(tex_diffuse, fs_in.tex_coord) * vec4(result, 1);

	};
"

hlsl[0] =
"
	float4x4 model;
	float4x4 projection;
	float4x4 view;

	float4 ambient_color = float4(1, 1, 1, 1);
	float ambient_intensity = 0.1;

	struct VertexShaderInput
	{
		float4 position : POSITION0;
	};

	struct VertexShaderOutput
	{
		float4 position : POSITION0;
	};

	VertexShaderOutput VertexShaderFunction(VertexShaderInput input)
	{
		VertexShaderOutput output;

		float4 model_position = mul(input.position, model);
		float4 view_position = mul(world_position, view);
		output.position = mul(view_position, projection);

		return output;
	}

	float4 PixelShaderFunction(VertexShaderOutput input) : COLOR0
	{
		return ambient_color * ambient_intensity;
	}

	technique Ambient
	{
		pass Pass1
		{
			VertexShader = compile vs_2_0 VertexShaderFunction();
			PixelShader = compile ps_2_0 PixelShaderFunction();
		}
	}
"
